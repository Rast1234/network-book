# 4. Транспортный уровень (transport)

*   **Тип данных:** сегменты, датаграммы
*   **Назначение:** прямая связь между отправителем и получателем, надежность, гарантия доставки и целостности
*   **Примеры:** TCP, UDP
*   **Действующие "лица"**: порты, сокеты, рукопожатия

Мы умеем найти нужное устройство и отправить ему пакет. Мы умеем провести пакет по нужному маршруту, чтобы он точно дошел. Но сеть может меняться, связь может пропадать, в пакетах могут меняться данные из-за помех. По разным причинам отправленные данные могут повреждаться или пропадать, приходить не в нужном порядке или не полностью. В некоторых ситуациях нам нет до этого дела, в некоторых - нам нужна гарантия того, что отправленное было доставлено в целости и сохранности. А еще нам нужно обеспечить одновременную работу кучи программ на одном устройстве (это называется **мультиплексирование**). Этим и занимаются протоколы транспортного уровня: UDP и TCP.


#### UDP

**_User Datagram Protocol._**

**Датаграмма** - блок информации, отправляемый без предварительной установки соединения и без подтверждений приема. Название было выбрано по аналогии с "телеграммой". К слову, Ethernet и IP - тоже датаграммные протоколы, потому что работают без подтверждений и прочих механизмов.

UDP позволяет отправлять и принимать датаграммы (просто наборы байт) без проверки на то, что они будут доставлены, без проверки на порядок, дубликаты и т.д. Это работает быстро и эффективно, используется в сетевых играх и при передаче файлов, например, torrent-клиентами. Но уже само приложение должно проверять полученные данные. Почему не TCP (о котором ниже)? Потому что TCP гарантирует целостность и порядок, но может задерживать прием данных, ожидая повторной доставки потерянных пакетов, а игре проще выбросить такие данные и работать с более свежими, чем ждать пока "доедут" старые. UDP также не требует дополнительных ресурсов от отправляющего и принимающего, поэтому позволяет серверу обрабатывать запросы от огромного количества клиентов.

Структура пакета:



*   Порт отправителя - 2 байта
*   Порт получателя - 2 байта
*   Длина датаграммы - 2 байта. Длина указана для всего пакета, т.е. данные вместе с заголовком.
*   Контрольная сумма - 2 байта
*   Данные. Максимальная длина - 65527, потому что в поле "Длина" можно указать максимум 65535, минус 8 байт заголовка. Но на самом деле нет. Дело в том, что UDP завернут в IP, у которого тоже максимальная длина 65535 минус 20 байт заголовка, поэтому весь UDP должен быть не больше 65507 байт. Но на самом деле это Ethernet вообще ограничивает размер до 1500 байт. С другой стороны, это ограничение почти всегда игнорируется.

Про сам UDP больше сказать нечего. Приложение просто получает у операционной системы UDP-сокет, прибитый к порту, отправляет или получает пакеты. О портах и сокетах будет немного ниже.


#### TCP

**Transmission Control Protocol**, протокол управления передачей. TCP обеспечивает надежную передачу пакетов между хостами: гарантирует последовательность (отправленные пакеты будут приняты в том же порядке), отсутствие дублей и потерянных пакетов. Это достигается благодаря установке соединения перед началом передачи и обменом подтверждениями при приеме. Сначала посмотрим на структуру пакета, а потом разберемся зачем все это нужно и как оно работает.



*   **Source port** - 2 байта, порт отправителя
*   **Destination port** - 2 байта, порт получателя
*   **Sequence Number** - 4 байта, порядковый номер пакета в серии
*   **Acknowledgment Number** - 4 байта, номер подтверждения
*   **Длина заголовка** - 4 **бита**
*   **Зарезервировано** - 6 **бит**
*   **Флаги** - 6 **бит**: URG, ACK, PSH, RST, SYN, FIN. Если бит 1, значит соответствующий флаг установлен, если 0 то нет. Названия - сокращения от Urgent, Acknowledgement, Push, Reset, Synchronize, Final.
*   **Размер окна** - 2 байта
*   **Контрольная сумма** - 2 байта
*   **Указатель важности** - 2 байта
*   **Опции** - поле переменной длины
*   **Данные**

Про порты написано в следующем разделе.

Порядковый номер позволяет отправлять большой массив данных, разделяя их на пакеты, а потом собирать на принимающей стороне обратно в большой массив. Это делает операционная система, т.е. приложение просто пишет в TCP-сокет байты, а дальше они рассовываются по пакетам и пакеты нумеруются. При приеме таких пакетов они собираются в правильной последовательности, если какой-то пакет пришел раньше времени, то приложение его не увидит, пока не придут все пакеты перед ним.

Длина заголовка позволяет указать, внезапно, длину заголовка, чтобы можно было заполнить разное число опций в поле Опции.

Зарезервированные биты были оставлены "на потом"; два уже пригодились и используются для указания на перегрузку в сети.

Контрольная сумма позволяет проверить целостность пакета, как и в других протоколах.

Остальные поля отдельно объяснять смысла нет.


#### Порты и сокеты

На одном хосте может работать много программ, которым нужен доступ в сеть. Чтобы различать, какой IP-пакет какой программе предназначен (**мультиплексирование**), на транспортном уровне в протоколах TCP и UDP предусмотрены **порты**. Это просто двухбайтное число (0-65535) в TCP или UDP пакете, которое позволяет операционной системе раздавать программам полученные данные. Порт обычно обозначается двоеточием после IP-адреса, с припиской, TCP или UDP. Например:



*   HTTP-сервера работают на порте TCP 80. То есть  открыть страницу по адресу 216.58.211.142:80 - это то же самое, что открыть браузер и набрать там этот IP-адрес, а порт добавится по умолчанию браузером. Ну и браузер знает, что запросы надо делать по протоколу TCP.
*   Сервера Doom (1 и 2) обычно работают на портах TCP 666 и UDP 666.
*   Исходящее соединение, например открытая страница в браузере, получает у операционки случайный порт.

Программа при работе с сетью запрашивает у операционной системы разрешение работать с определенным портом, и если порт не занят кем-то другим, получает **сокет** - интерфейс для работы с сетью. По сути, это структура в памяти, созданная системой и отданная программе. Программа работает с сокетом, а дальше все делает операционная система. Программа может ждать, пока что-то придет на этот порт, и посылать ответ. Так работает любой сервер. А может послать куда-то запрос, получить ответ и закрыть сокет (освободить порт), так работают клиенты, например браузер, в простом случае.

Есть разница между клиентскими и серверными сокетами.



*   Клиентский сокет - это по сути исходящее соединение, которое определяется четырьмя параметрами: свой IP, свой (исходящий) порт, IP получателя, порт получателя. Для подключения с другого порта или на другой адрес требуется создать новый сокет.
*   Серверный сокет - это интерфейс для входящих соединений. Заранее адрес и порт клиента неизвестны. Когда программа-сервер создает такой сокет, она ждет, пока на него придет пакет. Теперь известны те же 4 параметра: свой IP, свой порт, IP отправителя, порт отправителя. Это можно представить как клиентский сокет, и начать обрабатывать пакет. Если придет пакет от клиента с другим адресом или с другого порта, это уже новая комбинация этих четырех параметров и их можно обработать, не перепутав, какой ответ потом кому направить.


#### Магия

Теперь о том, как работает TCP. Прежде чем отправить какие-то данные, TCP устанавливает **соединение**. Это такой предварительный обмен сообщениями с получателем, чтобы удостовериться что он готов к приему. Потом идут передача данных и закрытие соединения с подтверждением что все успешно принято. На стороне клиента и сервера TCP имеет состояния, по сути это - конечный автомат.

_Небольшое отступление, если что-то непонятно, то можно пропустить и не заморачиваться:_


> Конечный автомат в информатике и математике - упрощенно говоря, это такая абстракция, модель устройства, которое имеет **состояния** и при определенных условиях **переходит** из одного состояния в другое. Нас интересует то, что сеанс (соединение) TCP представляет из себя такой автомат (точнее, два автомата - по одному у отправителя и получателя) и в каждый момент времени находится в каком-то из известных состояний, и ожидает перейти в другое при получении пакетов с нужными флагами. Или по таймеру.

Список состояний сеанса TCP (алгоритмы и пояснения будут дальше):



*   **CLOSED** Начальное состояние узла. Фактически фиктивное
*   **LISTEN** Сервер ожидает запросов установления соединения от клиента
*   **SYN-SENT** Клиент отправил запрос серверу на установление соединения и ожидает ответа
*   **SYN-RECEIVED** Сервер получил запрос на соединение, отправил ответный запрос и ожидает подтверждения
*   **ESTABLISHED** Соединение установлено, идет передача данных
*   **FIN-WAIT-1** Одна из сторон (назовем ее узел-1) завершает соединение, отправив сегмент с флагом FIN
*   **CLOSE-WAIT** Другая сторона (узел-2) переходит в это состояние, отправив, в свою очередь сегмент ACK и продолжает одностороннюю передачу
*   **FIN-WAIT-2** Узел-1 получает ACK, продолжает чтение и ждет получения сегмента с флагом FIN
*   **LAST-ACK** Узел-2 заканчивает передачу и отправляет сегмент с флагом FIN
*   **TIME-WAIT** Узел-1 получил сегмент с флагом FIN, отправил сегмент с флагом ACK и ждет 2*(макс. время жизни сегмента) секунд, перед окончательным закрытием соединения
*   **CLOSING** Обе стороны инициировали закрытие соединения одновременно: после отправки сегмента с флагом FIN узел-1 также получает сегмент FIN, отправляет ACK и находится в ожидании сегмента ACK (подтверждения на свой запрос о разъединении)


#### Рукопожатие

Процесс начала сеанса TCP (также называемый «рукопожатие» (англ. handshake)), состоит из трех шагов. Дальше - немного переработанные вырезки из википедии и викиучебника.



1. Узел **A** (был в состоянии CLOSED) посылает узлу **B** пакет с флагом SYN — приглашение к соединению и переходит в состояние SYN-SENT
2. **B** (был в состоянии LISTEN) получает пакет с флагом SYN, переходит в состояние SYN-RECEIVED, отвечает пакетом с флагами SYN и ACK — согласием об установлении соединения. Или он может отправить флаг RST, то есть отказ от соединения.
3. **A**, получив SYN ACK, посылает пакет ACK — подтверждение, что согласие получено и переходит в состояние ESTABLISHED. B получает этот пакет и тоже переходит в состояние ESTABLISHED. Если **A** получил RST, то он прекращает попытки соединиться с **B**. Если **A** не получил SYN ACK за несколько секунд (таймаут), он пробует сначала. Если **B** не получил ACK, то по таймауту закрывает соединение и переходит в режим CLOSED.

После этого соединение считается установленным, о чем нам говорит название состояния - ESTABLISHED - и можно передавать данные в обе стороны. «Соединение» означает, что узлы помнят друг о друге, нумеруют все пакеты, идущие в обе стороны, посылают подтверждения о получении каждого пакета и перепосылают потерявшиеся по дороге пакеты. Для узла A это соединение называется **исходящим**, а для узла B — **входящим**. Эти термины не имеют никакого отношения к входящему или исходящему трафику. Они указывают только инициатора соединения, то есть направление самого первого пакета (SYN). Любое установленное TCP соединение симметрично, и пакеты с данными по нему всегда идут в обе стороны.

Когда один из узлов решает, что пора заканчивать соединение, он посылает специальный пакет FIN, после этого узлы прощаются и разрывают соединение. Это "рукопожатие" можно перевести на человеческий язык так:



*   Эй, ты слушаешь?
*   Да / Нет
*   Ну тогда слушай. / … (нет так нет)

Процесс называется «трехэтапным рукопожатием» (англ. three way handshake), так как несмотря на то что возможен процесс установления соединения с использованием четырех сегментов (SYN в сторону сервера, ACK в сторону клиента, SYN в сторону клиента, ACK в сторону сервера), на практике для экономии времени используется три сегмента (SYN ACK в сторону клиента в одном пакете). Помимо смены состояний, TCP ведет подсчет номеров пакетов (поле в заголовке, **номер пакета**).

Вот пример соединения, в котором видно состояния, номера пакетов и флаги в них:


```
    TCP A                                            TCP B
   1.  CLOSED                                        LISTEN
   2.  SYN-SENT     → <SEQ=100><SYN>              →  SYN-RECEIVED
   3.  ESTABLISHED  ← <SEQ=300><ACK=101><SYN,ACK> ←  SYN-RECEIVED
   4.  ESTABLISHED  → <SEQ=101><ACK=301><ACK>     →  ESTABLISHED
   5.  ESTABLISHED  ← <SEQ=301><ACK=101><ACK>     ←  ESTABLISHED
```


В строке 2 TCP A начинает передачу сегмента SYN, говорящего об использовании номеров последовательности, начиная со 100. В строке 3 TCP B передает SYN и подтверждение для принятого SYN в адрес TCP A. Надо отметить, что поле подтверждения показывает ожидание TCP B приема номера последовательности 101, подтверждающего SYN с номером 100.

В строке 4 TCP A отвечает пустым сегментом с подтверждением ACK для сегмента SYN от TCP B; в строке 5 TCP B передает некоторые данные. Отметим, что номер подтверждения сегмента в строке 5 (ACK=101) совпадает с номером последовательности в строке 4 (SEQ=101), поскольку ACK не занимает пространства номеров последовательности (если это сделать, придется подтверждать подтверждения — ACK для ACK).


#### Передача данных

При обмене данными принимающий хост использует номер последовательности, содержащийся в получаемых сегментах, для восстановления их исходного порядка. Получатель уведомляет передающую сторону о номере последовательности, до которой он успешно получил данные, включая его в поле Номер подтверждения. Все получаемые данные, относящиеся к промежутку подтвержденных последовательностей, игнорируются. Если полученный сегмент содержит номер последовательности больший, чем ожидаемый, то данные из сегмента буферизируются (сохраняются во временной памяти), но номер подтвержденной последовательности не изменяется. Если впоследствии будет принят сегмент, относящийся к ожидаемому номеру последовательности, то порядок данных будет автоматически восстановлен исходя из номеров последовательностей в сегментах.

Для того, чтобы передающая сторона не отправляла данные интенсивнее, чем их может обработать приемник, TCP содержит средства управления потоком. Для этого используется поле **Размер окна**. В сегментах, направляемых от приемника передающей стороне, в поле «окно» указывается текущий размер приемного буфера. Передающая сторона сохраняет размер окна и отправляет данных не более, чем указал приемник. Если приемник указал нулевой размер окна, то передача данных в направлении этого узла не происходит, пока приемник не сообщит о большем размере окна.

В некоторых случаях передающее приложение может явно затребовать протолкнуть данные до некоторой последовательности принимающему приложению, не буферизируя их. Для этого используется флаг PSH. Если в полученном сегменте обнаруживается флаг PSH, то реализация TCP отдает все буферизированные на текущий момент данные принимающему приложению. «Проталкивание» используется, например, в интерактивных приложениях. В сетевых терминалах нет смысла ожидать ввода пользователя после того, как он закончил набирать команду. Поэтому последний сегмент, содержащий команду, обязан содержать флаг PSH, чтобы приложение на принимающей стороне смогло начать ее выполнение.

При приеме пакетов хост отвечает пакетом с подтверждением приема. Если источник не получил такой пакет за какое-то время, он считает данные не дошедшими до принимающего, и отправляет их заново. Это называется **retransmission **и повышает надежность доставки данных.


#### Закрытие соединения

Стороны могут независимо от друга захотеть закрыть соединение. Для корректного завершения сеанса используется алгоритм из четырех шагов. Почему-то он не называется "четверным рукопожатием", хотя в английском языке так и есть: **four-way handshake termination**.



1. Когда хост, пусть **A**, решает закрыть соединение, он посылает пакет с флагом FIN и переходит в состояние FIN_WAIT_1.
2. **B** получает этот пакет, переходит в состояние CLOSE_WAIT и отвечает пакетом с флагом ACK (подтверждает). **A**, получив ACK, переходит в FIN_WAIT_2. В процессе передачи данных могли еще остаться недоставленные или неподтвержденные пакеты, поэтому он не закрывает соединение, а продолжает получать и подтверждать пакеты, ожидая "последнего слова" от **B**.
3. Когда **B** заканчивает передачу данных и получает все соответствующие ACK, он посылает FIN и переходит в состояние LAST_ACK.
4. **A** получает FIN от **B** и отправляет ему последний ACK в подтверждение. **A** после этого ждет какое-то время (2*MSL), чтобы дошли пакеты которые могли быть отправлены **B** до этого, и закрывает сокет (состояние CLOSED). **B**, получив этот ACK, тоже закрывает сокет.

Этот алгоритм гарантирует, что все данные, которые были отправлены в момент начала закрытия соединения, будут доставлены до закрытия. После перехода в состояние CLOSED операционная система считает порт освободившимся и может создать новый сокет на этом порту для другого приложения.


#### Что-то пошло не так

При нормальной работе, автоматы TCP двух участников находятся в синхронизированном состоянии. А что произойдет, если какая-то из сторон перестанет посылать пакеты, отвечать на принятые, или начнет посылать пакеты с неожиданными флагами? Например, из-за сбоя в сети, или целенаправленно, в нарушение протокола? В этом случае автоматы будут рассинхронизированы: станет непонятно, чего ожидать от очередного пакета, и что делать дальше. В таком случае соединение называется **полуоткрытым **или **полузакрытым**. В общем случае, когда TCP получает что-то неожиданное, или не получает ничего, он закрывает соединение сразу или по таймеру.

**Half-closed connection** - это соединение в процессе нормального закрытия, когда одна сторона больше не посылает данные и ожидает FIN от второй стороны. Это можно использовать для создания односторонних соединений.

**Half-open connection** - когда одна сторона закрыла соединение, а вторая и не подозревает, что что-то произошло, и ждет продолжения общения. Тут стоит рассмотреть пару интересных случаев.


#### Keep-alive

После установления TCP соединения, хосты могут бесконечно долго находиться в состоянии ESTABLISHED, то есть не происходит никаких проверок на "активность" соединения. Узнать, что что-то пошло не так, можно, только послав данные и не получив ACK в ответ. Это хорошо, потому что позволяет соединению пережить временные пропадания связи (например, выпадение провода из компьютера, или перезагрузку роутера на пути пакета). Только вот здесь кроется проблема: предположим, хост B отправил что-то хосту A. На пути пакета был роутер, и ему сбросили настройки. Пакет не дошел до A. B это понял, потому что не получил ACK за отведенное время, попробовал отправить данные несколько раз (retransmission), только вот роутер больше не знает маршрута до A, и ничего так и не дошло. B закрыл соединение и продолжил работать. Но вот A просто считает, что B ничего не отправлял и по-прежнему ждет, занимая порт.

Для решения этой проблемы существует механизм keep-alive. Сама идея простая: по таймеру посылать пакет без данных, чтобы получить в ответ ACK и таким образом удостовериться, что соединение в порядке. Keep-alive есть в TCP, но его использование необязательно. Протоколы более высоких уровней тоже могут реализовывать свой keep-alive, что тоже сводится к периодической отправке TCP-пакетов и получении подтверждений.


#### SYN-flood

Если при тройном рукопожатии послать серверу только первый SYN, и забить на дальнейшие действия, сервер ответит SYN ACK и будет ждать ответного ACK. Проблема в том, что на сервере в процессе ожидания уже будет создан сокет под это полу-открытое соединение. Если сделать много SYN-запросов, то на сервере кончатся ресурсы: память будет занята сокетами. Это называется атакой **SYN-flood**, попытка завалить сервер SYN-пакетами, чтобы у него закончились ресурсы и он не смог обрабатывать нормальные запросы.

Эта проблема решается установкой небольшого таймаута на ожидание ACK при тройном рукопожатии и ограничением количества одновременных полуоткрытых _входящих_ соединений.

В Windows (до 2008 SP2 / Vista SP2) также было ограничение на количество _исходящих _соединений, т.е. нельзя одновременно послать много SYN, для предотвращения проведения SYN-flood атак с зараженных компьютеров. Это мешало работе некоторых программ, например торрент-клиентов, потому что они активно создают и разрывают сотни соединений. Для обхода этого ограничения нужно было пропатчить драйвер tcpip.sys.


#### Больше магии? Нет, спасибо

TCP - обширная и сложная тема, там есть много интересных механизмов и ситуаций, но пока что достаточно таких базовых вещей. Пожалуй, достаточно еще знать, что TCP пытается не допускать перегрузок в сети и поэтому скорость передачи может "плавать" и какое-то время разгоняться с нуля до максимума.


# Навигация

- [Пролог](README.md)
- [0. Поехали](0_start.md)
- [1. Физический уровень (physical)](1_physical.md)
- [2. Канальный уровень (data link)](2_data_link.md)
- [3. Сетевой уровень (network)](3_network.md)
- `4. Транспортный уровень (transport)`
- [5. Сеансовый уровень (session)](5_session.md)
- [6. Уровень представления (presentation)](6_presentation.md)
- [7. Прикладной уровень (application)](7_application.md)
- [8. Что осталось за кадром](8_end.md)
